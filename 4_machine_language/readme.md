### 241008
# 기계어
### <br/><br/><br/>

## 들어가며...
### 4장을 일단 3회 정독하였다. 3회를 정독한 이유는... 갑자기 레벨이 확 올라갔다. 감추어진 부분이 생각보다 많다. 책에서는 이를 추상화라고 표현하는데, 1부터 10까지의 단계 중 1~5단계 정도만 추상화에 대해 정확히 배웠고 나머지는 추상화가 감추어져 있다.
### 즉, 어떤 기능을 하는지만 알겠다는 것이다. 하지만 그 내부를 모르겠다.
### 그래서 3회를 읽었다. 그러면서 어느 정도 채워졌지만 그래도 채워지지 않는 부분들이 있다.
### 나는 갈 길이 멀다는 것을 알고 있었고, 지금은 그것을 정말 많이 느낀다.
### <br/><br/><br/>

## 확실히 이해한 부분
### 주제가 기계어다 보니 기계어에 대한 추상적인 기능을 아주 자세히, 이해하기 쉽게, 그것의 큰 의미적인 부분을 정말 잘 설명해주었다. 물론 기계어가 무엇인지는 알고 있었던 부분도 원활한 이해에 한몫을 한 것도 있긴 하다.
### 그리고 1, 2, 3장을 해오면서 모두 다 0과 1로 이루어진 이진수로 컴퓨터를 다루었고, 이를 이용하여 기초 논리 게이트부터 ALU, 메모리까지 직접 구현하였다.
### 이를 통해 0과 1이 컴퓨터에서 어떻게 작동하는지 확실히 안 시점에서 기계어에 대한 의미는 사실 이미 알고 있는 것이나 다름 없다고 봐도 무방하다 라고 표현할 수 있겠다.
### <br/>

### 그리고 사람은 0과 1로 된 언어를 읽기 어려워한다는 것은, 내가 인간이기에 느낄 수 있는 바, 그래서 인간이 읽기 쉽게 하는 방법이 필요해졌다는 것도 자연스럽게 받아들여졌다.
### 여기까지 오는 데에 그렇게 빈 공간도 없었고, 그냥 녹아 들어갔다. 
### 최초에는 0과 1의 규칙성으로 기호를 표현했다. 왜냐면 최초의 컨셉과 기술로는 그게 올바른 단계적인 접근 방법이었으니 말이다. 
### 그 다음에는 역으로 기호를 이용하여 미리 약속된(각 기호에 따라 메모리에 매핑된) 2진 코드로 표현할 수 있다는 생각에 도달하기까지 오래 걸리지 않았다.
### 그래서 탄생한 게 인간이 읽을 수 있는 기호로 이루어진, 기계어와 직접적인 연관관계가 있는 어셈블리어이(assembly language)다.
### 그리고 어셈블리어를 2진 코드로 번역하는 프로그램이 어셈블러(assembler)이다.
### <br/>

### 자 여기서 생각해보자. 어셈블리어는 기계어인가? 아주 정확하게 따진다면 기계어는 아니다. 기계어의 의미 자체는 말 그대로 기계어, 즉 기계가 이해할 수 있는 언어이다.
### 하지만 어셈블리어는 인간이 이해하는 언어이기 때문에 기계어가 아니라고 결론을 낼 수 있다. 하지만 나는 처음에 어셈블리어가 기계어라고 착각했다.
### 그럼에도 왜 어셈블리어를 기계어라고 표현하고, 또한 같은 파트에 등장할까? 그게 사실 핵심이다.
### <br/>

### 먼저 어셈블리어의 위키피디아의 이야기를 들어보자. 
### 어셈블리어를 '거의' 기계어로 취급한다. 하지만 어셈블리어는 기계어보다 더 고수준의 언어이다.
### 기계어는 오히려 '0과 1의 규칙성으로 기호를 표현'한 것과 같은 것이다. 그리고 기초 논리 게이트 또한 기계어이다.
#### ![image](https://github.com/user-attachments/assets/66b91cea-0f69-4a03-98e3-b8e70280fcdc)
### <br/>

### 어셈블리어는 기계어와 가장 직접적으로 연관이 있는 언어이다. 
### 어셈블러. 이 존재는 기계어로 한 번 변환 후 실행하는 것이니 기계어보다 느릴 수 밖에 없다(불가피함).
### <br/><br/><br/>


## 난해했던 부분
### 이해하기 어려웠던 부분이 있었다. 그리고 설명이 안 되고 넘어가는 부분도 많았다.
### <br/><br/>

### 1. 몇 가지 다른 타입의 레지스터 : 주소 레지스터(A), 데이터 레지스터(D), 선택된 데이터 메모리의 레지스터(M)
### 

### 2. 기계어 개요, 핵 기계어 파트
### 이 파트가 난해했던 부분은, 기계어 개요 파트가 기계어 설명이 아닌 어셈블리어를 같이 설명하고 있었기 때문이다. 
### 위의 어셈블리어에 대한 글을 읽어보면 알 수 있듯이, 사실 구분하지 않아도 된다고 생각한다.
### 그렇지만 분명히 다른 것이기 때문에 기계어와 어셈블리어 두 부분을 나누어서 설명하였으면 이렇게 혼동하지 않았고 더 좋았을 거라는 생각을 떨칠 수 없다.
### <br/>

### 혼동되는 가장 주요한 이유는, 기계어와 어셈블리어를 실제로도 구분하지 않는다는 것이다. 
### 그래서 기계어와 어셈블리어를 같이, 그리고 동시에 설명하고 있다. 마치 RAM과 ROM을 동시에 선택되지만 한 가지만 쓸 수 있다는 그 설명과 같다.
### 왜 굳이 구분하지 않아도 되냐면, 어셈블리어는 위키피디아 내용에서도 알 수 있듯 바로 직접적으로 연관된(일대일 대응이 되는) 언어이기 때문이다.
### <br/><br/>

### 3. 핵 기계어 : 핵 언어와 어셈블리어

- 레지스터의 사용 방법 및 특성(성격)
- 기호가 처리되는 메모리적인, 논리적인 매핑 방법(단순히 말해서 기호가 어떻게 읽힐 수 있는 것인가)
- 
