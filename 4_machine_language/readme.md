### 241009
# 기계어
### <br/><br/><br/>

## 들어가며...
### 4장을 일단 3회 정독하였다. 3회를 정독한 이유는... 갑자기 레벨이 확 올라갔다. 감추어진 부분이 생각보다 많다. 책에서는 이를 추상화라고 표현하는데, 1부터 10까지의 단계 중 1~5단계 정도만 추상화에 대해 정확히 배웠고 나머지는 추상화가 감추어져 있다.
### 즉, 어떤 기능을 하는지만 알겠다는 것이다. 하지만 그 내부를 모르겠다.
### 그래서 3회를 읽었다. 그러면서 어느 정도 채워졌지만 그래도 채워지지 않는 부분들이 있다.
### 나는 갈 길이 멀다는 것을 알고 있었고, 지금은 그것을 정말 많이 느낀다.
### <br/><br/><br/>

## 확실히 이해한 부분
### 주제가 기계어다 보니 기계어에 대한 추상적인 기능을 아주 자세히, 이해하기 쉽게, 그것의 큰 의미적인 부분을 정말 잘 설명해주었다. 물론 기계어가 무엇인지는 알고 있었던 부분도 원활한 이해에 한몫을 한 것도 있긴 하다.
### 그리고 1, 2, 3장을 해오면서 모두 다 0과 1로 이루어진 이진수로 컴퓨터를 다루었고, 이를 이용하여 기초 논리 게이트부터 ALU, 메모리까지 직접 구현하였다.
### 이를 통해 0과 1이 컴퓨터에서 어떻게 작동하는지 확실히 안 시점에서 기계어에 대한 의미는 사실 이미 알고 있는 것이나 다름 없다고 봐도 무방하다 라고 표현할 수 있겠다.
### <br/>

### 그리고 사람은 0과 1로 된 언어를 읽기 어려워한다는 것은, 내가 인간이기에 느낄 수 있는 바, 그래서 인간이 읽기 쉽게 하는 방법이 필요해졌다는 것도 자연스럽게 받아들여졌다.
### 여기까지 오는 데에 그렇게 빈 공간도 없었고, 그냥 녹아 들어갔다. 
### 최초에는 0과 1의 규칙성으로 기호를 표현했다. 왜냐면 최초의 컨셉과 기술로는 그게 올바른 단계적인 접근 방법이었으니 말이다. 
### 그 다음에는 역으로 기호를 이용하여 미리 약속된(각 기호에 따라 메모리에 매핑된) 2진 코드로 표현할 수 있다는 생각에 도달하기까지 오래 걸리지 않았다.
### 그래서 탄생한 게 인간이 읽을 수 있는 기호로 이루어진, 기계어와 직접적인 연관관계가 있는 어셈블리어이(assembly language)다.
### 그리고 어셈블리어를 2진 코드로 번역하는 프로그램이 어셈블러(assembler)이다.
### <br/>

### 자 여기서 생각해보자. 어셈블리어는 기계어인가? 아주 정확하게 따진다면 기계어는 아니다. 기계어의 의미 자체는 말 그대로 기계어, 즉 기계가 이해할 수 있는 언어이다.
### 하지만 어셈블리어는 인간이 이해하는 언어이기 때문에 기계어가 아니라고 결론을 낼 수 있다. 하지만 나는 처음에 어셈블리어가 기계어라고 착각했다.
### 그럼에도 왜 어셈블리어를 기계어라고 표현하고, 또한 같은 파트에 등장할까? 그게 사실 핵심이다.
### <br/>

### 먼저 어셈블리어의 위키피디아의 이야기를 들어보자. 
### 어셈블리어를 '거의' 기계어로 취급한다. 하지만 어셈블리어는 기계어보다 더 고수준의 언어이다.
### 기계어는 오히려 '0과 1의 규칙성으로 기호를 표현'한 것과 같은 것이다. 그리고 기초 논리 게이트 또한 기계어이다.
#### ![image](https://github.com/user-attachments/assets/66b91cea-0f69-4a03-98e3-b8e70280fcdc){: width="50%" height="50%"}
### <br/>

### 어셈블리어는 기계어와 가장 직접적으로 연관이 있는 언어이다. 
### 어셈블러. 이 존재는 기계어로 한 번 변환 후 실행하는 것이니 기계어보다 느릴 수 밖에 없다(불가피함).
### <br/><br/><br/>


# 난해했던 부분
### 이해하기 어려웠던 부분이 있었다. 그리고 설명이 안 되고 넘어가는 부분도 많았다.
### <br/><br/>

## 1. 레지스터의 설명과 몇 가지 다른 타입의 레지스터
### 주소 레지스터(A), 데이터 레지스터(D), 선택된 데이터 메모리의 레지스터(M)
### 레지스터의 설명은 2번 다른 곳에서 등장한다. 그리고 내용은 비슷하나 분명히 다른 뜻을 가지고 있다. 
### 앞의 쪽은 3장의 레지스터와 직접적으로 연관된 내용이었고, 뒤쪽의 내용은 바로 앞쪽 레지스터의 내용과 연관된 내용이었다. 이렇게 다른 파트에서 레지스터의 의미를 2번, 다른 의미로 이야기하면 혼동될 수 밖에 없다.
### <br/>

### 앞쪽에서는 데이터 레지스터와 주소 레지스터를 이야기했지만 문자 D와 A로 표현하지 않았고, 뒤쪽에서는 표현했다. 이 부분은 매우 혼동되는 부분이었다. 
### 같은 단어지만, 둘이 다른 건가 싶었다. 하지만 같은 것이었다.
### <br/>

### '선택된 데이터 메모리의 레지스터(M)'... 이미 이름부터가 난해하다. 그런데 천천히 읽어보면, 이렇게 표현하는 것이 가장 정확한 표현이다.
### 분리해서 살펴보자
### 데이터 메모리는 RAM을 뜻한다. 

<img src="https://github.com/user-attachments/assets/2bc791c8-b44e-458b-b84e-ec1d3431d07d" width="50%">

### <br/><br/>

### 그리고 선택된 데이터 메모리는 주소 레지스터(A)로 메모리 주소가 특정된(선택된) 데이터 메모리를 뜻한다.
### 선택된 데이터 메모리의 레지스터(M)란 RAM에서 해당 주소 안에 있는 실제 값이다.
### <br/><br/><br/>


## 2. 기계어 개요, 핵 기계어 파트
### 이 파트가 난해했던 이유는, 기계어 개요 파트가 기계어 설명이 아닌 어셈블리어를 같이 설명하고 있었기 때문이다. 
### 위의 어셈블리어에 대한 글을 읽어보면 알 수 있듯이, 사실 구분하지 않아도 된다고 생각한다.
### 그렇지만 분명히 다른 것이기 때문에 기계어와 어셈블리어 두 부분을 나누어서 설명하였으면 이렇게 혼동하지 않았고 더 좋았을 거라는 생각을 떨칠 수 없다.
### <br/>

### 혼동되는 가장 주요한 이유는, 기계어와 어셈블리어를 실제로도 구분하지 않는다는 것이다. 
### 그래서 기계어와 어셈블리어를 같이, 그리고 동시에 설명하고 있다. 마치 RAM과 ROM을 동시에 선택되지만 한 가지만 쓸 수 있다는 그 설명과 같다.
### 왜 굳이 구분하지 않아도 되냐면, 어셈블리어는 위키피디아 내용에서도 알 수 있듯 바로 직접적으로 연관된(일대일 대응이 되는) 언어이기 때문이다.
### <br/><br/><br/>


## 3. 레지스터의 사용 방법 및 특성(성격)
### 주소 레지스터(A), 데이터 레지스터(D), 선택된 데이터 메모리의 레지스터(M)
### 레지스터는 크게 A, D, M으로 구분된다. 먼저 각 관계성 파악이 어려웠다.
### 하지만 몇 번 읽어보면 잘 알 수 있다.
### 가장 쉽게 이해하는 방법은, 고수준의 언어로 표현해보는 것이다.
### <br/><br/>

### 파이썬을 생각해보자.
### A, M, D. 이것은 하나의 딕셔너리와 하나의 변수와 같다.
### A는 딕셔너리에서 key이고, M은 value이다.
### D는 그냥 정수형의 변수이다. 이를 이용해 M의 값을 저장하거나 M 값을 수정하기 위해(또는 값을 swap하기 위해) 임시로 값을 저장해놓는다.
### 이게 끝이다.
### <br/><br/>

### M과 D는 똑같이 값을 저장하는 역할을 하지만 차이가 있다. M보다 D가 더 저수준에 있어 고속 메모리 역할을 한다.
### M은 A로 주소를 알아야 접근 가능하고, 물론 시간복잡도가 O(1)이지만 한 번 주소를 타고 값을 조회해야 한다.
### 하지만 D는 다르다. D가 곧 레지스터이고 바로 조회된다.
### D는 CPU의 내부에 직접 존재하는 레지스터이고, M은 RAM에 저장되어 있는 레지스터이고 가져와서 써야 해서 접근 시간이 필요하다.
### <br/><br/>

### @n은 A의 주소 n을 의미한다.
### @x와 같이 변수를 선언할 수 있고, 변수명을 의미하기도 하며, 또한 변수명의 주소값을 가리키기도 한다. 그리고 M도 불러올 수 있다 ! 
### 매우 혼란스러웠던 부분.
### <br/>

### @n이 RAM과 ROM을 동시에 선택되는 특징을 가지고 있다는 것은 크게 받아들이기 어려운 부분은 아니었다.
### 아, 그렇구나, 둘 중에 하나를 쓰는구나하고 그냥 넘어갈 수 있는 부분이었다.
### <br/><br/>

### 이해하기 어렵고 감추어진 부분은 사실 ROM 부분이다. 이부분은 확실하게 설명이 부족하다.
### ROM 각 주소에 명령어가 저장되어 있고, 그걸 쓸 수 있다 정도만 알려준다. 그게 어떻게 작동하는지는 잘 모르겠다.
### 마찬가지로 스크린과 키보드의 동작이 어떻게 이어지는 것도 잘 모르겠다.
### 설명이 없으니 그냥 동작하는구나 로만 받아들일 수 밖에 없다.
### <br/><br/><br/>


## 4. 기호가 처리되는 메모리적인, 논리적인 매핑 방법과 그 구현 방법
### 단순히 말해서 기호가 어떻게 읽힐 수 있는 것인가에 대한 부분이다.
### 이 부분은 설명이 부족하다.
### <br/><br/><br/>


# 과제
### 내용의 개념적인 난이도에 비해, 사실 과제는 쉬운 편에 속한다.
### 하지만 I/O 처리 프로그램은... 설명이 좀 더 있었으면 좋겠다. ㅠㅠ
### 단순히 어셈블리어라는 프로그래밍 언어 하나 배우고 코딩 문제 2개 푸는 것과 같다.
- 곰셈 프로그램(multiple) : 곱셈을 하는 프로그램을 만들자.
- I/O 처리 프로그램 : 키보드 입력을 받자.
### <br/><br/><br/>

## I/O 처리 프로그램
### 화면에 검은색을 칠해야 한다.
### SCREEN은 다음의 특징을 가지고 있다.
- 왼쪽 상단부터 시작하고 SCREEN의 시작 주소는 16384이다.
- col = 512, row = 256개이다.
- 한 주소는 16비트를 가지며, 왼쪽부터 오른쪽으로 16픽셀만큼 한 묶음으로 색을 칠할 수 있다.
- 위 조건에 따라 마지막 픽셀 묶음의 주소는 16384 + (512 * (256/16)) - 1 = 24575이다.
  - 참고로 키보드는 주소 이름이 @KBD이고 주소값은 24576이다.
- 화면에 색을 칠하는 방법
  - M = 0이면 해당 주소의 16픽셀 전체가 하얀색
  - M = -1이먄 해당 주소의 16픽셀 전체가 검은색
### <br/><br/>

### 예를 들어서 이렇게 하면 맨 왼쪽 상단에 검은색이 칠해진다.
```
@SCREEN
M=-1
(END)
@END
0;JMP
```
#### ![image](https://github.com/user-attachments/assets/cf4c6010-c784-44d2-a14f-a5e1aeaefe57)
### <br/><br/>

### 그러면 전체 화면을 검은색으로 칠하려면 어떻게 해야할까?
### SCREEN 주소부터 루프를 돌면서 +1씩 주소를 맨 마지막 주소까지 접근하면서 M=-1을 설정하면 된다.
### 잘 안 보이는데, 검은색 라인을 잘 보면 왼쪽 상단부터 오른쪽으로 검은색이 칠해진다.

https://github.com/user-attachments/assets/eb1e68c0-fe32-4a5f-b430-7296fac22508

### <br/>

### 에니메이션을 끄고 보면 바로 칠해진다.
#### ![image](https://github.com/user-attachments/assets/2653b73d-3e74-4b5a-a42e-365df4fd5442)
### <br/><br/>

### 다음으로 키보드 입력에 대해 알아보자.
- @KBD로 주소를 호출할 수 있다.
- 주소 값은 24576
- 키보드가 눌리면 해당 코드가 M에 기록된다. 코드값은 아스키코드와 같지만, 지원하는 범위가 약간 다르다. 부록 5참고하면 된다.
- 눌리지 않고 있으면 M=0으로 기록된다.
### <br/><br/>

### 그럼 @KBD로 불러와서 값이 0이면 스크린을 흰색으로, 아니면 검은색으로 칠하면 되겠다.
#### 참고로 JEQ는 0이면 해당 주소로 점프, JGT는 0보다 크면 해당 주소로 점프다.
```
@KBD
D=M
@BLACK_SCREEN
D;JEQ
@WHITE_SCREEN
D;JGT
```
### <br/><br/>

### 테스트

https://github.com/user-attachments/assets/fee4bcf1-3f9d-40d7-98d1-5df8456d475d

### <br/><br/><br/>

## .hack
### 이거는 그냥 넘어가려고 한다. asm을 기반으로 해서 16비트로 변환하는 작업이라... 귀찮기도 하고 시간이 걸릴 것 같다.
### 그래서 다른 사람들 한 걸 그냥 참고하였다.
```
0100000000000000
1110110000010000
0000000000010000
1110001100001000
0110000000000000
1111110000010000
0000000000001100
1110001100000001
0000000000010001
1110101010001000
0000000000001110
1110101010000111
0000000000010001
1110111010001000
0000000000010001
1111110000010000
0000000000010000
1111110000100000
1110001100001000
0000000000010000
1111110111001000
1111110000010000
0110000000000000
1110010011010000
0000000000001110
1110001100000100
0000000000000000
1110101010000111
```
### <br/><br/>

### asm to hack 번역기를 개발할 수도 있다. 
### 이는 hack 언어의 명세를 따르면 가능하다.
- 0부터 15는 R0부터 R15로 특수하게 할당됨
- 변수는 16부터 주소가 바인딩
- SCREEN 주솟값은 16384 ~ 24575, KBD 주솟값은 24576
- A 명령어, C 명령어 규칙
#### ![image](https://github.com/user-attachments/assets/af576656-6342-4870-ad82-485f9c12a794)
### <br/><br/><br/>


## 과제를 진행하면서 의문이 들 수 있는 점
### 이런 거는 된다.
```
@n
M=M+1

@n
M=M-1

@n
M=-1

@n
M=1

@n
M=0

@n
M=D

@n
M=A
```
### <br/><br/>

### 이런 거는 안 된다.
```
@n
M=32

D=32
```
### <br/><br/>

### 왜 안 될까?
### 제어비트에 해당 연산을 지원하는 항목이 없기 때문이다.
### 위에 A 명령어, C 명령어에 대한 책 내용에서 cccccc라고 적힌 부분을 참고하자. 
### <br/><br/><br/>
